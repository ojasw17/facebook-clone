{"ast":null,"code":"// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process = global.process;\n\nconst processOk = function (process) {\n  return process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';\n}; // some kind of non-node environment, just no-op\n\n/* istanbul ignore if */\n\n\nif (!processOk(process)) {\n  module.exports = function () {};\n} else {\n  var assert = require('assert');\n\n  var signals = require('./signals.js');\n\n  var isWin = /^win/i.test(process.platform);\n\n  var EE = require('events');\n  /* istanbul ignore if */\n\n\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter;\n  }\n\n  var emitter;\n\n  if (process.__signal_exit_emitter__) {\n    emitter = process.__signal_exit_emitter__;\n  } else {\n    emitter = process.__signal_exit_emitter__ = new EE();\n    emitter.count = 0;\n    emitter.emitted = {};\n  } // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n\n\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity);\n    emitter.infinite = true;\n  }\n\n  module.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return;\n    }\n\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');\n\n    if (loaded === false) {\n      load();\n    }\n\n    var ev = 'exit';\n\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit';\n    }\n\n    var remove = function () {\n      emitter.removeListener(ev, cb);\n\n      if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {\n        unload();\n      }\n    };\n\n    emitter.on(ev, cb);\n    return remove;\n  };\n\n  var unload = function unload() {\n    if (!loaded || !processOk(global.process)) {\n      return;\n    }\n\n    loaded = false;\n    signals.forEach(function (sig) {\n      try {\n        process.removeListener(sig, sigListeners[sig]);\n      } catch (er) {}\n    });\n    process.emit = originalProcessEmit;\n    process.reallyExit = originalProcessReallyExit;\n    emitter.count -= 1;\n  };\n\n  module.exports.unload = unload;\n\n  var emit = function emit(event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return;\n    }\n\n    emitter.emitted[event] = true;\n    emitter.emit(event, code, signal);\n  }; // { <signal>: <listener fn>, ... }\n\n\n  var sigListeners = {};\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener() {\n      /* istanbul ignore if */\n      if (!processOk(global.process)) {\n        return;\n      } // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n\n\n      var listeners = process.listeners(sig);\n\n      if (listeners.length === emitter.count) {\n        unload();\n        emit('exit', null, sig);\n        /* istanbul ignore next */\n\n        emit('afterexit', null, sig);\n        /* istanbul ignore next */\n\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT';\n        }\n        /* istanbul ignore next */\n\n\n        process.kill(process.pid, sig);\n      }\n    };\n  });\n\n  module.exports.signals = function () {\n    return signals;\n  };\n\n  var loaded = false;\n\n  var load = function load() {\n    if (loaded || !processOk(global.process)) {\n      return;\n    }\n\n    loaded = true; // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n\n    emitter.count += 1;\n    signals = signals.filter(function (sig) {\n      try {\n        process.on(sig, sigListeners[sig]);\n        return true;\n      } catch (er) {\n        return false;\n      }\n    });\n    process.emit = processEmit;\n    process.reallyExit = processReallyExit;\n  };\n\n  module.exports.load = load;\n  var originalProcessReallyExit = process.reallyExit;\n\n  var processReallyExit = function processReallyExit(code) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return;\n    }\n\n    process.exitCode = code ||\n    /* istanbul ignore next */\n    0;\n    emit('exit', process.exitCode, null);\n    /* istanbul ignore next */\n\n    emit('afterexit', process.exitCode, null);\n    /* istanbul ignore next */\n\n    originalProcessReallyExit.call(process, process.exitCode);\n  };\n\n  var originalProcessEmit = process.emit;\n\n  var processEmit = function processEmit(ev, arg) {\n    if (ev === 'exit' && processOk(global.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process.exitCode = arg;\n      }\n\n      var ret = originalProcessEmit.apply(this, arguments);\n      /* istanbul ignore next */\n\n      emit('exit', process.exitCode, null);\n      /* istanbul ignore next */\n\n      emit('afterexit', process.exitCode, null);\n      /* istanbul ignore next */\n\n      return ret;\n    } else {\n      return originalProcessEmit.apply(this, arguments);\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/ojaswi/Social - Media web app/frontend-react-app/node_modules/signal-exit/index.js"],"names":["process","global","processOk","removeListener","emit","reallyExit","listeners","kill","pid","on","module","exports","assert","require","signals","isWin","test","platform","EE","EventEmitter","emitter","__signal_exit_emitter__","count","emitted","infinite","setMaxListeners","Infinity","cb","opts","equal","loaded","load","ev","alwaysLast","remove","length","unload","forEach","sig","sigListeners","er","originalProcessEmit","originalProcessReallyExit","event","code","signal","listener","filter","processEmit","processReallyExit","exitCode","call","arg","undefined","ret","apply","arguments"],"mappings":"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","sourcesContent":["// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process = global.process\n\nconst processOk = function (process) {\n  return process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function'\n}\n\n// some kind of non-node environment, just no-op\n/* istanbul ignore if */\nif (!processOk(process)) {\n  module.exports = function () {}\n} else {\n  var assert = require('assert')\n  var signals = require('./signals.js')\n  var isWin = /^win/i.test(process.platform)\n\n  var EE = require('events')\n  /* istanbul ignore if */\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter\n  }\n\n  var emitter\n  if (process.__signal_exit_emitter__) {\n    emitter = process.__signal_exit_emitter__\n  } else {\n    emitter = process.__signal_exit_emitter__ = new EE()\n    emitter.count = 0\n    emitter.emitted = {}\n  }\n\n  // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity)\n    emitter.infinite = true\n  }\n\n  module.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return\n    }\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n    if (loaded === false) {\n      load()\n    }\n\n    var ev = 'exit'\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit'\n    }\n\n    var remove = function () {\n      emitter.removeListener(ev, cb)\n      if (emitter.listeners('exit').length === 0 &&\n          emitter.listeners('afterexit').length === 0) {\n        unload()\n      }\n    }\n    emitter.on(ev, cb)\n\n    return remove\n  }\n\n  var unload = function unload () {\n    if (!loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = false\n\n    signals.forEach(function (sig) {\n      try {\n        process.removeListener(sig, sigListeners[sig])\n      } catch (er) {}\n    })\n    process.emit = originalProcessEmit\n    process.reallyExit = originalProcessReallyExit\n    emitter.count -= 1\n  }\n  module.exports.unload = unload\n\n  var emit = function emit (event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return\n    }\n    emitter.emitted[event] = true\n    emitter.emit(event, code, signal)\n  }\n\n  // { <signal>: <listener fn>, ... }\n  var sigListeners = {}\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener () {\n      /* istanbul ignore if */\n      if (!processOk(global.process)) {\n        return\n      }\n      // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n      var listeners = process.listeners(sig)\n      if (listeners.length === emitter.count) {\n        unload()\n        emit('exit', null, sig)\n        /* istanbul ignore next */\n        emit('afterexit', null, sig)\n        /* istanbul ignore next */\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT'\n        }\n        /* istanbul ignore next */\n        process.kill(process.pid, sig)\n      }\n    }\n  })\n\n  module.exports.signals = function () {\n    return signals\n  }\n\n  var loaded = false\n\n  var load = function load () {\n    if (loaded || !processOk(global.process)) {\n      return\n    }\n    loaded = true\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    emitter.count += 1\n\n    signals = signals.filter(function (sig) {\n      try {\n        process.on(sig, sigListeners[sig])\n        return true\n      } catch (er) {\n        return false\n      }\n    })\n\n    process.emit = processEmit\n    process.reallyExit = processReallyExit\n  }\n  module.exports.load = load\n\n  var originalProcessReallyExit = process.reallyExit\n  var processReallyExit = function processReallyExit (code) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return\n    }\n    process.exitCode = code || /* istanbul ignore next */ 0\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    /* istanbul ignore next */\n    originalProcessReallyExit.call(process, process.exitCode)\n  }\n\n  var originalProcessEmit = process.emit\n  var processEmit = function processEmit (ev, arg) {\n    if (ev === 'exit' && processOk(global.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process.exitCode = arg\n      }\n      var ret = originalProcessEmit.apply(this, arguments)\n      /* istanbul ignore next */\n      emit('exit', process.exitCode, null)\n      /* istanbul ignore next */\n      emit('afterexit', process.exitCode, null)\n      /* istanbul ignore next */\n      return ret\n    } else {\n      return originalProcessEmit.apply(this, arguments)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}